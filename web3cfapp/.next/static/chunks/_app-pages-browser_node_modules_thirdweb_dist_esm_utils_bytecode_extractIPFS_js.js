"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_thirdweb_dist_esm_utils_bytecode_extractIPFS_js"],{

/***/ "(app-pages-browser)/./node_modules/thirdweb/dist/esm/utils/base58/alphabet.js":
/*!*****************************************************************!*\
  !*** ./node_modules/thirdweb/dist/esm/utils/base58/alphabet.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ALPHABET: () => (/* binding */ ALPHABET)\n/* harmony export */ });\nconst ALPHABET = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\n//# sourceMappingURL=alphabet.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aGlyZHdlYi9kaXN0L2VzbS91dGlscy9iYXNlNTgvYWxwaGFiZXQuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPO0FBQ1AiLCJzb3VyY2VzIjpbIi9Vc2Vycy9kYW5pbG8vRGV2ZWxvcGVyL0VOVi9CbG9ja2NoYWluL3dlYjNwcm9qZWN0cy93ZWIzY2Yvd2ViM2NmYXBwL25vZGVfbW9kdWxlcy90aGlyZHdlYi9kaXN0L2VzbS91dGlscy9iYXNlNTgvYWxwaGFiZXQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IEFMUEhBQkVUID0gXCIxMjM0NTY3ODlBQkNERUZHSEpLTE1OUFFSU1RVVldYWVphYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6XCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hbHBoYWJldC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/thirdweb/dist/esm/utils/base58/alphabet.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/thirdweb/dist/esm/utils/base58/encode.js":
/*!***************************************************************!*\
  !*** ./node_modules/thirdweb/dist/esm/utils/base58/encode.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   base58Encode: () => (/* binding */ base58Encode)\n/* harmony export */ });\n/* harmony import */ var _alphabet_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./alphabet.js */ \"(app-pages-browser)/./node_modules/thirdweb/dist/esm/utils/base58/alphabet.js\");\n\nconst BASE = _alphabet_js__WEBPACK_IMPORTED_MODULE_0__.ALPHABET.length;\nconst LEADER = /* @__PURE__ */ (() => _alphabet_js__WEBPACK_IMPORTED_MODULE_0__.ALPHABET.charAt(0))();\nconst iFACTOR = /* @__PURE__ */ (() => Math.log(256) / Math.log(BASE))(); // log(256) / log(BASE), rounded up\n/**\n * Encodes a Uint8Array into a base58 string.\n * @param source - The Uint8Array to encode.\n * @returns The base58 encoded string.\n * @throws {TypeError} If the source is not a Uint8Array.\n * @throws {Error} If there is a non-zero carry during the encoding process.\n * @example\n * ```ts\n * import { base58Encode } from \"thirdweb/utils;\n * const source = new Uint8Array([0, 1, 2, 3, 4, 5]);\n * const encoded = base58Encode(source);\n * console.log(encoded);\n * ```\n */\nfunction base58Encode(source) {\n    if (!(source instanceof Uint8Array)) {\n        throw new TypeError(\"Expected Uint8Array\");\n    }\n    if (source.length === 0) {\n        return \"\";\n    }\n    // Skip & count leading zeroes.\n    let zeroes = 0;\n    let length = 0;\n    let pbegin = 0;\n    const pend = source.length;\n    while (pbegin !== pend && source[pbegin] === 0) {\n        pbegin++;\n        zeroes++;\n    }\n    // Allocate enough space in big-endian base58 representation.\n    const size = ((pend - pbegin) * iFACTOR + 1) >>> 0;\n    const b58 = new Uint8Array(size);\n    // Process the bytes.\n    while (pbegin !== pend) {\n        let carry = source[pbegin] || 0;\n        // Apply \"b58 = b58 * 256 + ch\".\n        let i = 0;\n        for (let it1 = size - 1; (carry !== 0 || i < length) && it1 !== -1; it1--, i++) {\n            carry += (256 * (b58[it1] || 0)) >>> 0;\n            b58[it1] = (carry % BASE) >>> 0;\n            carry = (carry / BASE) >>> 0;\n        }\n        if (carry !== 0) {\n            throw new Error(\"Non-zero carry\");\n        }\n        length = i;\n        pbegin++;\n    }\n    // Skip leading zeroes in base58 result.\n    let it2 = size - length;\n    while (it2 !== size && b58[it2] === 0) {\n        it2++;\n    }\n    // Translate the result into a string.\n    let str = LEADER.repeat(zeroes);\n    for (; it2 < size; ++it2) {\n        str += _alphabet_js__WEBPACK_IMPORTED_MODULE_0__.ALPHABET.charAt(b58[it2] || 0);\n    }\n    return str;\n}\n//# sourceMappingURL=encode.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aGlyZHdlYi9kaXN0L2VzbS91dGlscy9iYXNlNTgvZW5jb2RlLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXlDO0FBQ3pDLGFBQWEsa0RBQVE7QUFDckIsc0NBQXNDLGtEQUFRO0FBQzlDLDBFQUEwRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBLFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDJDQUEyQztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLGVBQWUsa0RBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9kYW5pbG8vRGV2ZWxvcGVyL0VOVi9CbG9ja2NoYWluL3dlYjNwcm9qZWN0cy93ZWIzY2Yvd2ViM2NmYXBwL25vZGVfbW9kdWxlcy90aGlyZHdlYi9kaXN0L2VzbS91dGlscy9iYXNlNTgvZW5jb2RlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFMUEhBQkVUIH0gZnJvbSBcIi4vYWxwaGFiZXQuanNcIjtcbmNvbnN0IEJBU0UgPSBBTFBIQUJFVC5sZW5ndGg7XG5jb25zdCBMRUFERVIgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IEFMUEhBQkVULmNoYXJBdCgwKSkoKTtcbmNvbnN0IGlGQUNUT1IgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IE1hdGgubG9nKDI1NikgLyBNYXRoLmxvZyhCQVNFKSkoKTsgLy8gbG9nKDI1NikgLyBsb2coQkFTRSksIHJvdW5kZWQgdXBcbi8qKlxuICogRW5jb2RlcyBhIFVpbnQ4QXJyYXkgaW50byBhIGJhc2U1OCBzdHJpbmcuXG4gKiBAcGFyYW0gc291cmNlIC0gVGhlIFVpbnQ4QXJyYXkgdG8gZW5jb2RlLlxuICogQHJldHVybnMgVGhlIGJhc2U1OCBlbmNvZGVkIHN0cmluZy5cbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgdGhlIHNvdXJjZSBpcyBub3QgYSBVaW50OEFycmF5LlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZXJlIGlzIGEgbm9uLXplcm8gY2FycnkgZHVyaW5nIHRoZSBlbmNvZGluZyBwcm9jZXNzLlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBiYXNlNThFbmNvZGUgfSBmcm9tIFwidGhpcmR3ZWIvdXRpbHM7XG4gKiBjb25zdCBzb3VyY2UgPSBuZXcgVWludDhBcnJheShbMCwgMSwgMiwgMywgNCwgNV0pO1xuICogY29uc3QgZW5jb2RlZCA9IGJhc2U1OEVuY29kZShzb3VyY2UpO1xuICogY29uc29sZS5sb2coZW5jb2RlZCk7XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJhc2U1OEVuY29kZShzb3VyY2UpIHtcbiAgICBpZiAoIShzb3VyY2UgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgVWludDhBcnJheVwiKTtcbiAgICB9XG4gICAgaWYgKHNvdXJjZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIC8vIFNraXAgJiBjb3VudCBsZWFkaW5nIHplcm9lcy5cbiAgICBsZXQgemVyb2VzID0gMDtcbiAgICBsZXQgbGVuZ3RoID0gMDtcbiAgICBsZXQgcGJlZ2luID0gMDtcbiAgICBjb25zdCBwZW5kID0gc291cmNlLmxlbmd0aDtcbiAgICB3aGlsZSAocGJlZ2luICE9PSBwZW5kICYmIHNvdXJjZVtwYmVnaW5dID09PSAwKSB7XG4gICAgICAgIHBiZWdpbisrO1xuICAgICAgICB6ZXJvZXMrKztcbiAgICB9XG4gICAgLy8gQWxsb2NhdGUgZW5vdWdoIHNwYWNlIGluIGJpZy1lbmRpYW4gYmFzZTU4IHJlcHJlc2VudGF0aW9uLlxuICAgIGNvbnN0IHNpemUgPSAoKHBlbmQgLSBwYmVnaW4pICogaUZBQ1RPUiArIDEpID4+PiAwO1xuICAgIGNvbnN0IGI1OCA9IG5ldyBVaW50OEFycmF5KHNpemUpO1xuICAgIC8vIFByb2Nlc3MgdGhlIGJ5dGVzLlxuICAgIHdoaWxlIChwYmVnaW4gIT09IHBlbmQpIHtcbiAgICAgICAgbGV0IGNhcnJ5ID0gc291cmNlW3BiZWdpbl0gfHwgMDtcbiAgICAgICAgLy8gQXBwbHkgXCJiNTggPSBiNTggKiAyNTYgKyBjaFwiLlxuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGZvciAobGV0IGl0MSA9IHNpemUgLSAxOyAoY2FycnkgIT09IDAgfHwgaSA8IGxlbmd0aCkgJiYgaXQxICE9PSAtMTsgaXQxLS0sIGkrKykge1xuICAgICAgICAgICAgY2FycnkgKz0gKDI1NiAqIChiNThbaXQxXSB8fCAwKSkgPj4+IDA7XG4gICAgICAgICAgICBiNThbaXQxXSA9IChjYXJyeSAlIEJBU0UpID4+PiAwO1xuICAgICAgICAgICAgY2FycnkgPSAoY2FycnkgLyBCQVNFKSA+Pj4gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FycnkgIT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vbi16ZXJvIGNhcnJ5XCIpO1xuICAgICAgICB9XG4gICAgICAgIGxlbmd0aCA9IGk7XG4gICAgICAgIHBiZWdpbisrO1xuICAgIH1cbiAgICAvLyBTa2lwIGxlYWRpbmcgemVyb2VzIGluIGJhc2U1OCByZXN1bHQuXG4gICAgbGV0IGl0MiA9IHNpemUgLSBsZW5ndGg7XG4gICAgd2hpbGUgKGl0MiAhPT0gc2l6ZSAmJiBiNThbaXQyXSA9PT0gMCkge1xuICAgICAgICBpdDIrKztcbiAgICB9XG4gICAgLy8gVHJhbnNsYXRlIHRoZSByZXN1bHQgaW50byBhIHN0cmluZy5cbiAgICBsZXQgc3RyID0gTEVBREVSLnJlcGVhdCh6ZXJvZXMpO1xuICAgIGZvciAoOyBpdDIgPCBzaXplOyArK2l0Mikge1xuICAgICAgICBzdHIgKz0gQUxQSEFCRVQuY2hhckF0KGI1OFtpdDJdIHx8IDApO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW5jb2RlLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/thirdweb/dist/esm/utils/base58/encode.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/thirdweb/dist/esm/utils/bytecode/cbor-decode.js":
/*!**********************************************************************!*\
  !*** ./node_modules/thirdweb/dist/esm/utils/bytecode/cbor-decode.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decode: () => (/* binding */ decode)\n/* harmony export */ });\n/* biome-ignore-all lint: IGNORED */\n// original source: https://github.com/kriszyp/cbor-x/blob/master/decode.js\n// heavily modified to remove all non-essential code\n// TODO: re-enable typescript and properly type this\n// @ts-nocheck - TODO: re-enable typescript and properly type this\nlet src;\nlet srcEnd;\nlet position = 0;\nconst EMPTY_ARRAY = [];\nlet strings = EMPTY_ARRAY;\nlet stringPosition = 0;\nlet currentDecoder = {};\nlet currentStructures;\nlet srcString;\nconst srcStringStart = 0;\nlet srcStringEnd = 0;\nlet bundledStrings;\nlet referenceMap;\nconst currentExtensions = [];\nlet packedValues;\nlet dataView;\nconst defaultOptions = {\n    mapsAsObjects: true,\n    useRecords: false,\n};\nfunction readFixedString(length) {\n    let result;\n    if (length < 16) {\n        if ((result = shortStringInJS(length)))\n            return result;\n    }\n    if (length > 64 && decoder)\n        return decoder.decode(src.subarray(position, (position += length)));\n    const end = position + length;\n    const units = [];\n    result = \"\";\n    while (position < end) {\n        const byte1 = src[position++];\n        if ((byte1 & 0x80) === 0) {\n            // 1 byte\n            units.push(byte1);\n        }\n        else if ((byte1 & 0xe0) === 0xc0) {\n            // 2 bytes\n            const byte2 = src[position++] & 0x3f;\n            units.push(((byte1 & 0x1f) << 6) | byte2);\n        }\n        else if ((byte1 & 0xf0) === 0xe0) {\n            // 3 bytes\n            const byte2 = src[position++] & 0x3f;\n            const byte3 = src[position++] & 0x3f;\n            units.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3);\n        }\n        else if ((byte1 & 0xf8) === 0xf0) {\n            // 4 bytes\n            const byte2 = src[position++] & 0x3f;\n            const byte3 = src[position++] & 0x3f;\n            const byte4 = src[position++] & 0x3f;\n            let unit = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4;\n            if (unit > 0xffff) {\n                unit -= 0x10000;\n                units.push(((unit >>> 10) & 0x3ff) | 0xd800);\n                unit = 0xdc00 | (unit & 0x3ff);\n            }\n            units.push(unit);\n        }\n        else {\n            units.push(byte1);\n        }\n        if (units.length >= 0x1000) {\n            result += fromCharCode.apply(String, units);\n            units.length = 0;\n        }\n    }\n    if (units.length > 0) {\n        result += fromCharCode.apply(String, units);\n    }\n    return result;\n}\nclass Decoder {\n    constructor() {\n        Object.assign(this, defaultOptions);\n    }\n    decodeKey(key) {\n        return key;\n    }\n    decode(source, end = -1) {\n        srcEnd = end > -1 ? end : source.length;\n        position = 0;\n        stringPosition = 0;\n        srcStringEnd = 0;\n        srcString = null;\n        strings = EMPTY_ARRAY;\n        bundledStrings = null;\n        src = source;\n        // this provides cached access to the data view for a buffer if it is getting reused, which is a recommend\n        // technique for getting data from a database where it can be copied into an existing buffer instead of creating\n        // new ones\n        try {\n            dataView =\n                source.dataView ||\n                    (source.dataView = new DataView(source.buffer, source.byteOffset, source.byteLength));\n        }\n        catch (error) {\n            // if it doesn't have a buffer, maybe it is the wrong type of object\n            src = null;\n            if (source instanceof Uint8Array) {\n                throw error;\n            }\n            throw new Error(`Source must be a Uint8Array or Buffer but was a ${source && typeof source === \"object\"\n                ? source.constructor.name\n                : typeof source}`);\n        }\n        if (this instanceof Decoder) {\n            currentDecoder = this;\n            packedValues =\n                this.sharedValues &&\n                    (this.pack\n                        ? new Array(this.maxPrivatePackedValues || 16).concat(this.sharedValues)\n                        : this.sharedValues);\n            if (!currentStructures || currentStructures.length > 0) {\n                currentStructures = [];\n            }\n        }\n        else {\n            currentDecoder = defaultOptions;\n            if (!currentStructures || currentStructures.length > 0) {\n                currentStructures = [];\n            }\n            packedValues = null;\n        }\n        return checkedRead();\n    }\n}\nfunction checkedRead() {\n    try {\n        const result = read();\n        if (bundledStrings) {\n            if (position >= bundledStrings.postBundlePosition) {\n                const error = new Error(\"Unexpected bundle position\");\n                error.incomplete = true;\n                throw error;\n            }\n            // bundled strings to skip past\n            position = bundledStrings.postBundlePosition;\n            bundledStrings = null;\n        }\n        if (position === srcEnd) {\n            // finished reading this source, cleanup references\n            currentStructures = null;\n            src = null;\n            if (referenceMap) {\n                referenceMap = null;\n            }\n        }\n        else if (position > srcEnd) {\n            // over read\n            const error = new Error(\"Unexpected end of CBOR data\");\n            error.incomplete = true;\n            throw error;\n        }\n        else {\n            throw new Error(\"Data read, but end of buffer not reached\");\n        }\n        // else more to read, but we are reading sequentially, so don't clear source yet\n        return result;\n    }\n    catch (error) {\n        clearSource();\n        if (error instanceof RangeError ||\n            error.message.startsWith(\"Unexpected end of buffer\")) {\n            error.incomplete = true;\n        }\n        throw error;\n    }\n}\nfunction read() {\n    let token = src[position++];\n    const majorType = token >> 5;\n    token = token & 0x1f;\n    if (token > 0x17) {\n        switch (token) {\n            case 0x18:\n                token = src[position++];\n                break;\n            default:\n                throw new Error(`Unknown token ${token}`);\n        }\n    }\n    switch (majorType) {\n        case 0: // positive int\n            return token;\n        case 1: // negative int\n            return ~token;\n        case 2: // buffer\n            return readBin(token);\n        case 3: // string\n            if (srcStringEnd >= position) {\n                return srcString.slice(position - srcStringStart, (position += token) - srcStringStart);\n            }\n            if (srcStringEnd === 0 && srcEnd < 140 && token < 32) {\n                // for small blocks, avoiding the overhead of the extract call is helpful\n                const string = token < 16 ? shortStringInJS(token) : longStringInJS(token);\n                if (string !== null) {\n                    return string;\n                }\n            }\n            return readFixedString(token);\n        case 4: {\n            // array\n            const array = new Array(token);\n            for (let i = 0; i < token; i++) {\n                array[i] = read();\n            }\n            return array;\n        }\n        case 5: {\n            // map\n            const object = {};\n            for (let i = 0; i < token; i++) {\n                object[safeKey(read())] = read();\n            }\n            return object;\n        }\n        default: // negative int\n            if (Number.isNaN(token)) {\n                const error = new Error(\"Unexpected end of CBOR data\");\n                error.incomplete = true;\n                throw error;\n            }\n            throw new Error(`Unknown CBOR token ${token}`);\n    }\n}\nfunction safeKey(key) {\n    // protect against prototype pollution\n    if (typeof key === \"string\") {\n        return key === \"__proto__\" ? \"__proto_\" : key;\n    }\n    if (typeof key !== \"object\") {\n        return key.toString();\n    }\n    // protect against expensive (DoS) string conversions\n    throw new Error(`Invalid property name type ${typeof key}`);\n}\nconst fromCharCode = String.fromCharCode;\nfunction longStringInJS(length) {\n    const start = position;\n    const bytes = new Array(length);\n    for (let i = 0; i < length; i++) {\n        const byte = src[position++];\n        if ((byte & 0x80) > 0) {\n            position = start;\n            return;\n        }\n        bytes[i] = byte;\n    }\n    return fromCharCode.apply(String, bytes);\n}\nfunction shortStringInJS(length) {\n    if (length < 4) {\n        if (length < 2) {\n            if (length === 0) {\n                return \"\";\n            }\n            const a = src[position++];\n            if ((a & 0x80) > 1) {\n                position -= 1;\n                return;\n            }\n            return fromCharCode(a);\n        }\n        const a = src[position++];\n        const b = src[position++];\n        if ((a & 0x80) > 0 || (b & 0x80) > 0) {\n            position -= 2;\n            return;\n        }\n        if (length < 3) {\n            return fromCharCode(a, b);\n        }\n        const c = src[position++];\n        if ((c & 0x80) > 0) {\n            position -= 3;\n            return;\n        }\n        return fromCharCode(a, b, c);\n    }\n    const a = src[position++];\n    const b = src[position++];\n    const c = src[position++];\n    const d = src[position++];\n    if ((a & 0x80) > 0 || (b & 0x80) > 0 || (c & 0x80) > 0 || (d & 0x80) > 0) {\n        position -= 4;\n        return;\n    }\n    if (length < 6) {\n        if (length === 4) {\n            return fromCharCode(a, b, c, d);\n        }\n        const e = src[position++];\n        if ((e & 0x80) > 0) {\n            position -= 5;\n            return;\n        }\n        return fromCharCode(a, b, c, d, e);\n    }\n    if (length < 8) {\n        const e = src[position++];\n        const f = src[position++];\n        if ((e & 0x80) > 0 || (f & 0x80) > 0) {\n            position -= 6;\n            return;\n        }\n        if (length < 7) {\n            return fromCharCode(a, b, c, d, e, f);\n        }\n        const g = src[position++];\n        if ((g & 0x80) > 0) {\n            position -= 7;\n            return;\n        }\n        return fromCharCode(a, b, c, d, e, f, g);\n    }\n    const e = src[position++];\n    const f = src[position++];\n    const g = src[position++];\n    const h = src[position++];\n    if ((e & 0x80) > 0 || (f & 0x80) > 0 || (g & 0x80) > 0 || (h & 0x80) > 0) {\n        position -= 8;\n        return;\n    }\n    if (length < 10) {\n        if (length === 8) {\n            return fromCharCode(a, b, c, d, e, f, g, h);\n        }\n        const i = src[position++];\n        if ((i & 0x80) > 0) {\n            position -= 9;\n            return;\n        }\n        return fromCharCode(a, b, c, d, e, f, g, h, i);\n    }\n    if (length < 12) {\n        const i = src[position++];\n        const j = src[position++];\n        if ((i & 0x80) > 0 || (j & 0x80) > 0) {\n            position -= 10;\n            return;\n        }\n        if (length < 11) {\n            return fromCharCode(a, b, c, d, e, f, g, h, i, j);\n        }\n        const k = src[position++];\n        if ((k & 0x80) > 0) {\n            position -= 11;\n            return;\n        }\n        return fromCharCode(a, b, c, d, e, f, g, h, i, j, k);\n    }\n    const i = src[position++];\n    const j = src[position++];\n    const k = src[position++];\n    const l = src[position++];\n    if ((i & 0x80) > 0 || (j & 0x80) > 0 || (k & 0x80) > 0 || (l & 0x80) > 0) {\n        position -= 12;\n        return;\n    }\n    if (length < 14) {\n        if (length === 12) {\n            return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l);\n        }\n        const m = src[position++];\n        if ((m & 0x80) > 0) {\n            position -= 13;\n            return;\n        }\n        return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m);\n    }\n    const m = src[position++];\n    const n = src[position++];\n    if ((m & 0x80) > 0 || (n & 0x80) > 0) {\n        position -= 14;\n        return;\n    }\n    if (length < 15) {\n        return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n);\n    }\n    const o = src[position++];\n    if ((o & 0x80) > 0) {\n        position -= 15;\n        return;\n    }\n    return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o);\n}\nfunction readBin(length) {\n    return currentDecoder.copyBuffers\n        ? // specifically use the copying slice (not the node one)\n            Uint8Array.prototype.slice.call(src, position, (position += length))\n        : src.subarray(position, (position += length));\n}\nconst glbl = { Error, RegExp };\ncurrentExtensions[27] = (data) => {\n    // http://cbor.schmorp.de/generic-object\n    return (glbl[data[0]] || Error)(data[1], data[2]);\n};\nconst packedTable = (read_) => {\n    if (src[position++] !== 0x84) {\n        const error = new Error(\"Packed values structure must be followed by a 4 element array\");\n        if (src.length < position) {\n            error.incomplete = true;\n        }\n        throw error;\n    }\n    const newPackedValues = read_(); // packed values\n    if (!newPackedValues || !newPackedValues.length) {\n        const error = new Error(\"Packed values structure must be followed by a 4 element array\");\n        error.incomplete = true;\n        throw error;\n    }\n    packedValues = packedValues\n        ? newPackedValues.concat(packedValues.slice(newPackedValues.length))\n        : newPackedValues;\n    packedValues.prefixes = read_();\n    packedValues.suffixes = read_();\n    return read_(); // read the rump\n};\npackedTable.handlesRead = true;\ncurrentExtensions[28] = (read_) => {\n    // shareable http://cbor.schmorp.de/value-sharing (for structured clones)\n    if (!referenceMap) {\n        referenceMap = new Map();\n        referenceMap.id = 0;\n    }\n    const id = referenceMap.id++;\n    const token = src[position];\n    let target;\n    // TODO: handle Maps, Sets, and other types that can cycle; this is complicated, because you potentially need to read\n    // ahead past references to record structure definitions\n    if (token >> 5 === 4) {\n        target = [];\n    }\n    else {\n        target = {};\n    }\n    const refEntry = { target }; // a placeholder object\n    referenceMap.set(id, refEntry);\n    const targetProperties = read_(); // read the next value as the target object to id\n    if (refEntry.used) {\n        // there is a cycle, so we have to assign properties to original target\n        return Object.assign(target, targetProperties);\n    }\n    refEntry.target = targetProperties; // the placeholder wasn't used, replace with the deserialized one\n    return targetProperties; // no cycle, can just use the returned read object\n};\nfunction clearSource() {\n    src = null;\n    referenceMap = null;\n    currentStructures = null;\n}\nconst mult10 = new Array(147); // this is a table matching binary exponents to the multiplier to determine significant digit rounding\nfor (let i = 0; i < 256; i++) {\n    mult10[i] = /* @__PURE__ */ (() => Number(`1e${Math.floor(45.15 - i * 0.30103)}`))();\n}\nconst defaultDecoder = new Decoder();\nconst decode = defaultDecoder.decode;\n//# sourceMappingURL=cbor-decode.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aGlyZHdlYi9kaXN0L2VzbS91dGlscy9ieXRlY29kZS9jYm9yLWRlY29kZS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0U7QUFDL0U7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxNQUFNO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixXQUFXO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFdBQVc7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsTUFBTTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELFdBQVc7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFVBQVU7QUFDakM7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEMsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQixnQkFBZ0IsU0FBUztBQUN6QixtREFBbUQsZ0NBQWdDO0FBQ25GO0FBQ0E7QUFDTztBQUNQIiwic291cmNlcyI6WyIvVXNlcnMvZGFuaWxvL0RldmVsb3Blci9FTlYvQmxvY2tjaGFpbi93ZWIzcHJvamVjdHMvd2ViM2NmL3dlYjNjZmFwcC9ub2RlX21vZHVsZXMvdGhpcmR3ZWIvZGlzdC9lc20vdXRpbHMvYnl0ZWNvZGUvY2Jvci1kZWNvZGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogYmlvbWUtaWdub3JlLWFsbCBsaW50OiBJR05PUkVEICovXG4vLyBvcmlnaW5hbCBzb3VyY2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9rcmlzenlwL2Nib3IteC9ibG9iL21hc3Rlci9kZWNvZGUuanNcbi8vIGhlYXZpbHkgbW9kaWZpZWQgdG8gcmVtb3ZlIGFsbCBub24tZXNzZW50aWFsIGNvZGVcbi8vIFRPRE86IHJlLWVuYWJsZSB0eXBlc2NyaXB0IGFuZCBwcm9wZXJseSB0eXBlIHRoaXNcbi8vIEB0cy1ub2NoZWNrIC0gVE9ETzogcmUtZW5hYmxlIHR5cGVzY3JpcHQgYW5kIHByb3Blcmx5IHR5cGUgdGhpc1xubGV0IHNyYztcbmxldCBzcmNFbmQ7XG5sZXQgcG9zaXRpb24gPSAwO1xuY29uc3QgRU1QVFlfQVJSQVkgPSBbXTtcbmxldCBzdHJpbmdzID0gRU1QVFlfQVJSQVk7XG5sZXQgc3RyaW5nUG9zaXRpb24gPSAwO1xubGV0IGN1cnJlbnREZWNvZGVyID0ge307XG5sZXQgY3VycmVudFN0cnVjdHVyZXM7XG5sZXQgc3JjU3RyaW5nO1xuY29uc3Qgc3JjU3RyaW5nU3RhcnQgPSAwO1xubGV0IHNyY1N0cmluZ0VuZCA9IDA7XG5sZXQgYnVuZGxlZFN0cmluZ3M7XG5sZXQgcmVmZXJlbmNlTWFwO1xuY29uc3QgY3VycmVudEV4dGVuc2lvbnMgPSBbXTtcbmxldCBwYWNrZWRWYWx1ZXM7XG5sZXQgZGF0YVZpZXc7XG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBtYXBzQXNPYmplY3RzOiB0cnVlLFxuICAgIHVzZVJlY29yZHM6IGZhbHNlLFxufTtcbmZ1bmN0aW9uIHJlYWRGaXhlZFN0cmluZyhsZW5ndGgpIHtcbiAgICBsZXQgcmVzdWx0O1xuICAgIGlmIChsZW5ndGggPCAxNikge1xuICAgICAgICBpZiAoKHJlc3VsdCA9IHNob3J0U3RyaW5nSW5KUyhsZW5ndGgpKSlcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGlmIChsZW5ndGggPiA2NCAmJiBkZWNvZGVyKVxuICAgICAgICByZXR1cm4gZGVjb2Rlci5kZWNvZGUoc3JjLnN1YmFycmF5KHBvc2l0aW9uLCAocG9zaXRpb24gKz0gbGVuZ3RoKSkpO1xuICAgIGNvbnN0IGVuZCA9IHBvc2l0aW9uICsgbGVuZ3RoO1xuICAgIGNvbnN0IHVuaXRzID0gW107XG4gICAgcmVzdWx0ID0gXCJcIjtcbiAgICB3aGlsZSAocG9zaXRpb24gPCBlbmQpIHtcbiAgICAgICAgY29uc3QgYnl0ZTEgPSBzcmNbcG9zaXRpb24rK107XG4gICAgICAgIGlmICgoYnl0ZTEgJiAweDgwKSA9PT0gMCkge1xuICAgICAgICAgICAgLy8gMSBieXRlXG4gICAgICAgICAgICB1bml0cy5wdXNoKGJ5dGUxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoYnl0ZTEgJiAweGUwKSA9PT0gMHhjMCkge1xuICAgICAgICAgICAgLy8gMiBieXRlc1xuICAgICAgICAgICAgY29uc3QgYnl0ZTIgPSBzcmNbcG9zaXRpb24rK10gJiAweDNmO1xuICAgICAgICAgICAgdW5pdHMucHVzaCgoKGJ5dGUxICYgMHgxZikgPDwgNikgfCBieXRlMik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKGJ5dGUxICYgMHhmMCkgPT09IDB4ZTApIHtcbiAgICAgICAgICAgIC8vIDMgYnl0ZXNcbiAgICAgICAgICAgIGNvbnN0IGJ5dGUyID0gc3JjW3Bvc2l0aW9uKytdICYgMHgzZjtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGUzID0gc3JjW3Bvc2l0aW9uKytdICYgMHgzZjtcbiAgICAgICAgICAgIHVuaXRzLnB1c2goKChieXRlMSAmIDB4MWYpIDw8IDEyKSB8IChieXRlMiA8PCA2KSB8IGJ5dGUzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoYnl0ZTEgJiAweGY4KSA9PT0gMHhmMCkge1xuICAgICAgICAgICAgLy8gNCBieXRlc1xuICAgICAgICAgICAgY29uc3QgYnl0ZTIgPSBzcmNbcG9zaXRpb24rK10gJiAweDNmO1xuICAgICAgICAgICAgY29uc3QgYnl0ZTMgPSBzcmNbcG9zaXRpb24rK10gJiAweDNmO1xuICAgICAgICAgICAgY29uc3QgYnl0ZTQgPSBzcmNbcG9zaXRpb24rK10gJiAweDNmO1xuICAgICAgICAgICAgbGV0IHVuaXQgPSAoKGJ5dGUxICYgMHgwNykgPDwgMHgxMikgfCAoYnl0ZTIgPDwgMHgwYykgfCAoYnl0ZTMgPDwgMHgwNikgfCBieXRlNDtcbiAgICAgICAgICAgIGlmICh1bml0ID4gMHhmZmZmKSB7XG4gICAgICAgICAgICAgICAgdW5pdCAtPSAweDEwMDAwO1xuICAgICAgICAgICAgICAgIHVuaXRzLnB1c2goKCh1bml0ID4+PiAxMCkgJiAweDNmZikgfCAweGQ4MDApO1xuICAgICAgICAgICAgICAgIHVuaXQgPSAweGRjMDAgfCAodW5pdCAmIDB4M2ZmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVuaXRzLnB1c2godW5pdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB1bml0cy5wdXNoKGJ5dGUxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodW5pdHMubGVuZ3RoID49IDB4MTAwMCkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IGZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIHVuaXRzKTtcbiAgICAgICAgICAgIHVuaXRzLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHVuaXRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmVzdWx0ICs9IGZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIHVuaXRzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNsYXNzIERlY29kZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIGRlZmF1bHRPcHRpb25zKTtcbiAgICB9XG4gICAgZGVjb2RlS2V5KGtleSkge1xuICAgICAgICByZXR1cm4ga2V5O1xuICAgIH1cbiAgICBkZWNvZGUoc291cmNlLCBlbmQgPSAtMSkge1xuICAgICAgICBzcmNFbmQgPSBlbmQgPiAtMSA/IGVuZCA6IHNvdXJjZS5sZW5ndGg7XG4gICAgICAgIHBvc2l0aW9uID0gMDtcbiAgICAgICAgc3RyaW5nUG9zaXRpb24gPSAwO1xuICAgICAgICBzcmNTdHJpbmdFbmQgPSAwO1xuICAgICAgICBzcmNTdHJpbmcgPSBudWxsO1xuICAgICAgICBzdHJpbmdzID0gRU1QVFlfQVJSQVk7XG4gICAgICAgIGJ1bmRsZWRTdHJpbmdzID0gbnVsbDtcbiAgICAgICAgc3JjID0gc291cmNlO1xuICAgICAgICAvLyB0aGlzIHByb3ZpZGVzIGNhY2hlZCBhY2Nlc3MgdG8gdGhlIGRhdGEgdmlldyBmb3IgYSBidWZmZXIgaWYgaXQgaXMgZ2V0dGluZyByZXVzZWQsIHdoaWNoIGlzIGEgcmVjb21tZW5kXG4gICAgICAgIC8vIHRlY2huaXF1ZSBmb3IgZ2V0dGluZyBkYXRhIGZyb20gYSBkYXRhYmFzZSB3aGVyZSBpdCBjYW4gYmUgY29waWVkIGludG8gYW4gZXhpc3RpbmcgYnVmZmVyIGluc3RlYWQgb2YgY3JlYXRpbmdcbiAgICAgICAgLy8gbmV3IG9uZXNcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRhdGFWaWV3ID1cbiAgICAgICAgICAgICAgICBzb3VyY2UuZGF0YVZpZXcgfHxcbiAgICAgICAgICAgICAgICAgICAgKHNvdXJjZS5kYXRhVmlldyA9IG5ldyBEYXRhVmlldyhzb3VyY2UuYnVmZmVyLCBzb3VyY2UuYnl0ZU9mZnNldCwgc291cmNlLmJ5dGVMZW5ndGgpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIGlmIGl0IGRvZXNuJ3QgaGF2ZSBhIGJ1ZmZlciwgbWF5YmUgaXQgaXMgdGhlIHdyb25nIHR5cGUgb2Ygb2JqZWN0XG4gICAgICAgICAgICBzcmMgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHNvdXJjZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU291cmNlIG11c3QgYmUgYSBVaW50OEFycmF5IG9yIEJ1ZmZlciBidXQgd2FzIGEgJHtzb3VyY2UgJiYgdHlwZW9mIHNvdXJjZSA9PT0gXCJvYmplY3RcIlxuICAgICAgICAgICAgICAgID8gc291cmNlLmNvbnN0cnVjdG9yLm5hbWVcbiAgICAgICAgICAgICAgICA6IHR5cGVvZiBzb3VyY2V9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBEZWNvZGVyKSB7XG4gICAgICAgICAgICBjdXJyZW50RGVjb2RlciA9IHRoaXM7XG4gICAgICAgICAgICBwYWNrZWRWYWx1ZXMgPVxuICAgICAgICAgICAgICAgIHRoaXMuc2hhcmVkVmFsdWVzICYmXG4gICAgICAgICAgICAgICAgICAgICh0aGlzLnBhY2tcbiAgICAgICAgICAgICAgICAgICAgICAgID8gbmV3IEFycmF5KHRoaXMubWF4UHJpdmF0ZVBhY2tlZFZhbHVlcyB8fCAxNikuY29uY2F0KHRoaXMuc2hhcmVkVmFsdWVzKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB0aGlzLnNoYXJlZFZhbHVlcyk7XG4gICAgICAgICAgICBpZiAoIWN1cnJlbnRTdHJ1Y3R1cmVzIHx8IGN1cnJlbnRTdHJ1Y3R1cmVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50U3RydWN0dXJlcyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY3VycmVudERlY29kZXIgPSBkZWZhdWx0T3B0aW9ucztcbiAgICAgICAgICAgIGlmICghY3VycmVudFN0cnVjdHVyZXMgfHwgY3VycmVudFN0cnVjdHVyZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRTdHJ1Y3R1cmVzID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYWNrZWRWYWx1ZXMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGVja2VkUmVhZCgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrZWRSZWFkKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlYWQoKTtcbiAgICAgICAgaWYgKGJ1bmRsZWRTdHJpbmdzKSB7XG4gICAgICAgICAgICBpZiAocG9zaXRpb24gPj0gYnVuZGxlZFN0cmluZ3MucG9zdEJ1bmRsZVBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIGJ1bmRsZSBwb3NpdGlvblwiKTtcbiAgICAgICAgICAgICAgICBlcnJvci5pbmNvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGJ1bmRsZWQgc3RyaW5ncyB0byBza2lwIHBhc3RcbiAgICAgICAgICAgIHBvc2l0aW9uID0gYnVuZGxlZFN0cmluZ3MucG9zdEJ1bmRsZVBvc2l0aW9uO1xuICAgICAgICAgICAgYnVuZGxlZFN0cmluZ3MgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gc3JjRW5kKSB7XG4gICAgICAgICAgICAvLyBmaW5pc2hlZCByZWFkaW5nIHRoaXMgc291cmNlLCBjbGVhbnVwIHJlZmVyZW5jZXNcbiAgICAgICAgICAgIGN1cnJlbnRTdHJ1Y3R1cmVzID0gbnVsbDtcbiAgICAgICAgICAgIHNyYyA9IG51bGw7XG4gICAgICAgICAgICBpZiAocmVmZXJlbmNlTWFwKSB7XG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlTWFwID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwb3NpdGlvbiA+IHNyY0VuZCkge1xuICAgICAgICAgICAgLy8gb3ZlciByZWFkXG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgZW5kIG9mIENCT1IgZGF0YVwiKTtcbiAgICAgICAgICAgIGVycm9yLmluY29tcGxldGUgPSB0cnVlO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEYXRhIHJlYWQsIGJ1dCBlbmQgb2YgYnVmZmVyIG5vdCByZWFjaGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVsc2UgbW9yZSB0byByZWFkLCBidXQgd2UgYXJlIHJlYWRpbmcgc2VxdWVudGlhbGx5LCBzbyBkb24ndCBjbGVhciBzb3VyY2UgeWV0XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBjbGVhclNvdXJjZSgpO1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBSYW5nZUVycm9yIHx8XG4gICAgICAgICAgICBlcnJvci5tZXNzYWdlLnN0YXJ0c1dpdGgoXCJVbmV4cGVjdGVkIGVuZCBvZiBidWZmZXJcIikpIHtcbiAgICAgICAgICAgIGVycm9yLmluY29tcGxldGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlYWQoKSB7XG4gICAgbGV0IHRva2VuID0gc3JjW3Bvc2l0aW9uKytdO1xuICAgIGNvbnN0IG1ham9yVHlwZSA9IHRva2VuID4+IDU7XG4gICAgdG9rZW4gPSB0b2tlbiAmIDB4MWY7XG4gICAgaWYgKHRva2VuID4gMHgxNykge1xuICAgICAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAgICAgICBjYXNlIDB4MTg6XG4gICAgICAgICAgICAgICAgdG9rZW4gPSBzcmNbcG9zaXRpb24rK107XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biB0b2tlbiAke3Rva2VufWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN3aXRjaCAobWFqb3JUeXBlKSB7XG4gICAgICAgIGNhc2UgMDogLy8gcG9zaXRpdmUgaW50XG4gICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgIGNhc2UgMTogLy8gbmVnYXRpdmUgaW50XG4gICAgICAgICAgICByZXR1cm4gfnRva2VuO1xuICAgICAgICBjYXNlIDI6IC8vIGJ1ZmZlclxuICAgICAgICAgICAgcmV0dXJuIHJlYWRCaW4odG9rZW4pO1xuICAgICAgICBjYXNlIDM6IC8vIHN0cmluZ1xuICAgICAgICAgICAgaWYgKHNyY1N0cmluZ0VuZCA+PSBwb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBzcmNTdHJpbmcuc2xpY2UocG9zaXRpb24gLSBzcmNTdHJpbmdTdGFydCwgKHBvc2l0aW9uICs9IHRva2VuKSAtIHNyY1N0cmluZ1N0YXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzcmNTdHJpbmdFbmQgPT09IDAgJiYgc3JjRW5kIDwgMTQwICYmIHRva2VuIDwgMzIpIHtcbiAgICAgICAgICAgICAgICAvLyBmb3Igc21hbGwgYmxvY2tzLCBhdm9pZGluZyB0aGUgb3ZlcmhlYWQgb2YgdGhlIGV4dHJhY3QgY2FsbCBpcyBoZWxwZnVsXG4gICAgICAgICAgICAgICAgY29uc3Qgc3RyaW5nID0gdG9rZW4gPCAxNiA/IHNob3J0U3RyaW5nSW5KUyh0b2tlbikgOiBsb25nU3RyaW5nSW5KUyh0b2tlbik7XG4gICAgICAgICAgICAgICAgaWYgKHN0cmluZyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZWFkRml4ZWRTdHJpbmcodG9rZW4pO1xuICAgICAgICBjYXNlIDQ6IHtcbiAgICAgICAgICAgIC8vIGFycmF5XG4gICAgICAgICAgICBjb25zdCBhcnJheSA9IG5ldyBBcnJheSh0b2tlbik7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRva2VuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhcnJheVtpXSA9IHJlYWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhcnJheTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDU6IHtcbiAgICAgICAgICAgIC8vIG1hcFxuICAgICAgICAgICAgY29uc3Qgb2JqZWN0ID0ge307XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRva2VuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBvYmplY3Rbc2FmZUtleShyZWFkKCkpXSA9IHJlYWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDogLy8gbmVnYXRpdmUgaW50XG4gICAgICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKHRva2VuKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKFwiVW5leHBlY3RlZCBlbmQgb2YgQ0JPUiBkYXRhXCIpO1xuICAgICAgICAgICAgICAgIGVycm9yLmluY29tcGxldGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIENCT1IgdG9rZW4gJHt0b2tlbn1gKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzYWZlS2V5KGtleSkge1xuICAgIC8vIHByb3RlY3QgYWdhaW5zdCBwcm90b3R5cGUgcG9sbHV0aW9uXG4gICAgaWYgKHR5cGVvZiBrZXkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIGtleSA9PT0gXCJfX3Byb3RvX19cIiA/IFwiX19wcm90b19cIiA6IGtleTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBrZXkgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgcmV0dXJuIGtleS50b1N0cmluZygpO1xuICAgIH1cbiAgICAvLyBwcm90ZWN0IGFnYWluc3QgZXhwZW5zaXZlIChEb1MpIHN0cmluZyBjb252ZXJzaW9uc1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwcm9wZXJ0eSBuYW1lIHR5cGUgJHt0eXBlb2Yga2V5fWApO1xufVxuY29uc3QgZnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcbmZ1bmN0aW9uIGxvbmdTdHJpbmdJbkpTKGxlbmd0aCkge1xuICAgIGNvbnN0IHN0YXJ0ID0gcG9zaXRpb247XG4gICAgY29uc3QgYnl0ZXMgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGJ5dGUgPSBzcmNbcG9zaXRpb24rK107XG4gICAgICAgIGlmICgoYnl0ZSAmIDB4ODApID4gMCkge1xuICAgICAgICAgICAgcG9zaXRpb24gPSBzdGFydDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBieXRlc1tpXSA9IGJ5dGU7XG4gICAgfVxuICAgIHJldHVybiBmcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBieXRlcyk7XG59XG5mdW5jdGlvbiBzaG9ydFN0cmluZ0luSlMobGVuZ3RoKSB7XG4gICAgaWYgKGxlbmd0aCA8IDQpIHtcbiAgICAgICAgaWYgKGxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgIGlmIChsZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGEgPSBzcmNbcG9zaXRpb24rK107XG4gICAgICAgICAgICBpZiAoKGEgJiAweDgwKSA+IDEpIHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiAtPSAxO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmcm9tQ2hhckNvZGUoYSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYSA9IHNyY1twb3NpdGlvbisrXTtcbiAgICAgICAgY29uc3QgYiA9IHNyY1twb3NpdGlvbisrXTtcbiAgICAgICAgaWYgKChhICYgMHg4MCkgPiAwIHx8IChiICYgMHg4MCkgPiAwKSB7XG4gICAgICAgICAgICBwb3NpdGlvbiAtPSAyO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZW5ndGggPCAzKSB7XG4gICAgICAgICAgICByZXR1cm4gZnJvbUNoYXJDb2RlKGEsIGIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGMgPSBzcmNbcG9zaXRpb24rK107XG4gICAgICAgIGlmICgoYyAmIDB4ODApID4gMCkge1xuICAgICAgICAgICAgcG9zaXRpb24gLT0gMztcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnJvbUNoYXJDb2RlKGEsIGIsIGMpO1xuICAgIH1cbiAgICBjb25zdCBhID0gc3JjW3Bvc2l0aW9uKytdO1xuICAgIGNvbnN0IGIgPSBzcmNbcG9zaXRpb24rK107XG4gICAgY29uc3QgYyA9IHNyY1twb3NpdGlvbisrXTtcbiAgICBjb25zdCBkID0gc3JjW3Bvc2l0aW9uKytdO1xuICAgIGlmICgoYSAmIDB4ODApID4gMCB8fCAoYiAmIDB4ODApID4gMCB8fCAoYyAmIDB4ODApID4gMCB8fCAoZCAmIDB4ODApID4gMCkge1xuICAgICAgICBwb3NpdGlvbiAtPSA0O1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChsZW5ndGggPCA2KSB7XG4gICAgICAgIGlmIChsZW5ndGggPT09IDQpIHtcbiAgICAgICAgICAgIHJldHVybiBmcm9tQ2hhckNvZGUoYSwgYiwgYywgZCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZSA9IHNyY1twb3NpdGlvbisrXTtcbiAgICAgICAgaWYgKChlICYgMHg4MCkgPiAwKSB7XG4gICAgICAgICAgICBwb3NpdGlvbiAtPSA1O1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmcm9tQ2hhckNvZGUoYSwgYiwgYywgZCwgZSk7XG4gICAgfVxuICAgIGlmIChsZW5ndGggPCA4KSB7XG4gICAgICAgIGNvbnN0IGUgPSBzcmNbcG9zaXRpb24rK107XG4gICAgICAgIGNvbnN0IGYgPSBzcmNbcG9zaXRpb24rK107XG4gICAgICAgIGlmICgoZSAmIDB4ODApID4gMCB8fCAoZiAmIDB4ODApID4gMCkge1xuICAgICAgICAgICAgcG9zaXRpb24gLT0gNjtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuZ3RoIDwgNykge1xuICAgICAgICAgICAgcmV0dXJuIGZyb21DaGFyQ29kZShhLCBiLCBjLCBkLCBlLCBmKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBnID0gc3JjW3Bvc2l0aW9uKytdO1xuICAgICAgICBpZiAoKGcgJiAweDgwKSA+IDApIHtcbiAgICAgICAgICAgIHBvc2l0aW9uIC09IDc7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZyb21DaGFyQ29kZShhLCBiLCBjLCBkLCBlLCBmLCBnKTtcbiAgICB9XG4gICAgY29uc3QgZSA9IHNyY1twb3NpdGlvbisrXTtcbiAgICBjb25zdCBmID0gc3JjW3Bvc2l0aW9uKytdO1xuICAgIGNvbnN0IGcgPSBzcmNbcG9zaXRpb24rK107XG4gICAgY29uc3QgaCA9IHNyY1twb3NpdGlvbisrXTtcbiAgICBpZiAoKGUgJiAweDgwKSA+IDAgfHwgKGYgJiAweDgwKSA+IDAgfHwgKGcgJiAweDgwKSA+IDAgfHwgKGggJiAweDgwKSA+IDApIHtcbiAgICAgICAgcG9zaXRpb24gLT0gODtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobGVuZ3RoIDwgMTApIHtcbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gOCkge1xuICAgICAgICAgICAgcmV0dXJuIGZyb21DaGFyQ29kZShhLCBiLCBjLCBkLCBlLCBmLCBnLCBoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpID0gc3JjW3Bvc2l0aW9uKytdO1xuICAgICAgICBpZiAoKGkgJiAweDgwKSA+IDApIHtcbiAgICAgICAgICAgIHBvc2l0aW9uIC09IDk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZyb21DaGFyQ29kZShhLCBiLCBjLCBkLCBlLCBmLCBnLCBoLCBpKTtcbiAgICB9XG4gICAgaWYgKGxlbmd0aCA8IDEyKSB7XG4gICAgICAgIGNvbnN0IGkgPSBzcmNbcG9zaXRpb24rK107XG4gICAgICAgIGNvbnN0IGogPSBzcmNbcG9zaXRpb24rK107XG4gICAgICAgIGlmICgoaSAmIDB4ODApID4gMCB8fCAoaiAmIDB4ODApID4gMCkge1xuICAgICAgICAgICAgcG9zaXRpb24gLT0gMTA7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlbmd0aCA8IDExKSB7XG4gICAgICAgICAgICByZXR1cm4gZnJvbUNoYXJDb2RlKGEsIGIsIGMsIGQsIGUsIGYsIGcsIGgsIGksIGopO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGsgPSBzcmNbcG9zaXRpb24rK107XG4gICAgICAgIGlmICgoayAmIDB4ODApID4gMCkge1xuICAgICAgICAgICAgcG9zaXRpb24gLT0gMTE7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZyb21DaGFyQ29kZShhLCBiLCBjLCBkLCBlLCBmLCBnLCBoLCBpLCBqLCBrKTtcbiAgICB9XG4gICAgY29uc3QgaSA9IHNyY1twb3NpdGlvbisrXTtcbiAgICBjb25zdCBqID0gc3JjW3Bvc2l0aW9uKytdO1xuICAgIGNvbnN0IGsgPSBzcmNbcG9zaXRpb24rK107XG4gICAgY29uc3QgbCA9IHNyY1twb3NpdGlvbisrXTtcbiAgICBpZiAoKGkgJiAweDgwKSA+IDAgfHwgKGogJiAweDgwKSA+IDAgfHwgKGsgJiAweDgwKSA+IDAgfHwgKGwgJiAweDgwKSA+IDApIHtcbiAgICAgICAgcG9zaXRpb24gLT0gMTI7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGxlbmd0aCA8IDE0KSB7XG4gICAgICAgIGlmIChsZW5ndGggPT09IDEyKSB7XG4gICAgICAgICAgICByZXR1cm4gZnJvbUNoYXJDb2RlKGEsIGIsIGMsIGQsIGUsIGYsIGcsIGgsIGksIGosIGssIGwpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG0gPSBzcmNbcG9zaXRpb24rK107XG4gICAgICAgIGlmICgobSAmIDB4ODApID4gMCkge1xuICAgICAgICAgICAgcG9zaXRpb24gLT0gMTM7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZyb21DaGFyQ29kZShhLCBiLCBjLCBkLCBlLCBmLCBnLCBoLCBpLCBqLCBrLCBsLCBtKTtcbiAgICB9XG4gICAgY29uc3QgbSA9IHNyY1twb3NpdGlvbisrXTtcbiAgICBjb25zdCBuID0gc3JjW3Bvc2l0aW9uKytdO1xuICAgIGlmICgobSAmIDB4ODApID4gMCB8fCAobiAmIDB4ODApID4gMCkge1xuICAgICAgICBwb3NpdGlvbiAtPSAxNDtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobGVuZ3RoIDwgMTUpIHtcbiAgICAgICAgcmV0dXJuIGZyb21DaGFyQ29kZShhLCBiLCBjLCBkLCBlLCBmLCBnLCBoLCBpLCBqLCBrLCBsLCBtLCBuKTtcbiAgICB9XG4gICAgY29uc3QgbyA9IHNyY1twb3NpdGlvbisrXTtcbiAgICBpZiAoKG8gJiAweDgwKSA+IDApIHtcbiAgICAgICAgcG9zaXRpb24gLT0gMTU7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIGZyb21DaGFyQ29kZShhLCBiLCBjLCBkLCBlLCBmLCBnLCBoLCBpLCBqLCBrLCBsLCBtLCBuLCBvKTtcbn1cbmZ1bmN0aW9uIHJlYWRCaW4obGVuZ3RoKSB7XG4gICAgcmV0dXJuIGN1cnJlbnREZWNvZGVyLmNvcHlCdWZmZXJzXG4gICAgICAgID8gLy8gc3BlY2lmaWNhbGx5IHVzZSB0aGUgY29weWluZyBzbGljZSAobm90IHRoZSBub2RlIG9uZSlcbiAgICAgICAgICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoc3JjLCBwb3NpdGlvbiwgKHBvc2l0aW9uICs9IGxlbmd0aCkpXG4gICAgICAgIDogc3JjLnN1YmFycmF5KHBvc2l0aW9uLCAocG9zaXRpb24gKz0gbGVuZ3RoKSk7XG59XG5jb25zdCBnbGJsID0geyBFcnJvciwgUmVnRXhwIH07XG5jdXJyZW50RXh0ZW5zaW9uc1syN10gPSAoZGF0YSkgPT4ge1xuICAgIC8vIGh0dHA6Ly9jYm9yLnNjaG1vcnAuZGUvZ2VuZXJpYy1vYmplY3RcbiAgICByZXR1cm4gKGdsYmxbZGF0YVswXV0gfHwgRXJyb3IpKGRhdGFbMV0sIGRhdGFbMl0pO1xufTtcbmNvbnN0IHBhY2tlZFRhYmxlID0gKHJlYWRfKSA9PiB7XG4gICAgaWYgKHNyY1twb3NpdGlvbisrXSAhPT0gMHg4NCkge1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihcIlBhY2tlZCB2YWx1ZXMgc3RydWN0dXJlIG11c3QgYmUgZm9sbG93ZWQgYnkgYSA0IGVsZW1lbnQgYXJyYXlcIik7XG4gICAgICAgIGlmIChzcmMubGVuZ3RoIDwgcG9zaXRpb24pIHtcbiAgICAgICAgICAgIGVycm9yLmluY29tcGxldGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBjb25zdCBuZXdQYWNrZWRWYWx1ZXMgPSByZWFkXygpOyAvLyBwYWNrZWQgdmFsdWVzXG4gICAgaWYgKCFuZXdQYWNrZWRWYWx1ZXMgfHwgIW5ld1BhY2tlZFZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoXCJQYWNrZWQgdmFsdWVzIHN0cnVjdHVyZSBtdXN0IGJlIGZvbGxvd2VkIGJ5IGEgNCBlbGVtZW50IGFycmF5XCIpO1xuICAgICAgICBlcnJvci5pbmNvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIHBhY2tlZFZhbHVlcyA9IHBhY2tlZFZhbHVlc1xuICAgICAgICA/IG5ld1BhY2tlZFZhbHVlcy5jb25jYXQocGFja2VkVmFsdWVzLnNsaWNlKG5ld1BhY2tlZFZhbHVlcy5sZW5ndGgpKVxuICAgICAgICA6IG5ld1BhY2tlZFZhbHVlcztcbiAgICBwYWNrZWRWYWx1ZXMucHJlZml4ZXMgPSByZWFkXygpO1xuICAgIHBhY2tlZFZhbHVlcy5zdWZmaXhlcyA9IHJlYWRfKCk7XG4gICAgcmV0dXJuIHJlYWRfKCk7IC8vIHJlYWQgdGhlIHJ1bXBcbn07XG5wYWNrZWRUYWJsZS5oYW5kbGVzUmVhZCA9IHRydWU7XG5jdXJyZW50RXh0ZW5zaW9uc1syOF0gPSAocmVhZF8pID0+IHtcbiAgICAvLyBzaGFyZWFibGUgaHR0cDovL2Nib3Iuc2NobW9ycC5kZS92YWx1ZS1zaGFyaW5nIChmb3Igc3RydWN0dXJlZCBjbG9uZXMpXG4gICAgaWYgKCFyZWZlcmVuY2VNYXApIHtcbiAgICAgICAgcmVmZXJlbmNlTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICByZWZlcmVuY2VNYXAuaWQgPSAwO1xuICAgIH1cbiAgICBjb25zdCBpZCA9IHJlZmVyZW5jZU1hcC5pZCsrO1xuICAgIGNvbnN0IHRva2VuID0gc3JjW3Bvc2l0aW9uXTtcbiAgICBsZXQgdGFyZ2V0O1xuICAgIC8vIFRPRE86IGhhbmRsZSBNYXBzLCBTZXRzLCBhbmQgb3RoZXIgdHlwZXMgdGhhdCBjYW4gY3ljbGU7IHRoaXMgaXMgY29tcGxpY2F0ZWQsIGJlY2F1c2UgeW91IHBvdGVudGlhbGx5IG5lZWQgdG8gcmVhZFxuICAgIC8vIGFoZWFkIHBhc3QgcmVmZXJlbmNlcyB0byByZWNvcmQgc3RydWN0dXJlIGRlZmluaXRpb25zXG4gICAgaWYgKHRva2VuID4+IDUgPT09IDQpIHtcbiAgICAgICAgdGFyZ2V0ID0gW107XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0YXJnZXQgPSB7fTtcbiAgICB9XG4gICAgY29uc3QgcmVmRW50cnkgPSB7IHRhcmdldCB9OyAvLyBhIHBsYWNlaG9sZGVyIG9iamVjdFxuICAgIHJlZmVyZW5jZU1hcC5zZXQoaWQsIHJlZkVudHJ5KTtcbiAgICBjb25zdCB0YXJnZXRQcm9wZXJ0aWVzID0gcmVhZF8oKTsgLy8gcmVhZCB0aGUgbmV4dCB2YWx1ZSBhcyB0aGUgdGFyZ2V0IG9iamVjdCB0byBpZFxuICAgIGlmIChyZWZFbnRyeS51c2VkKSB7XG4gICAgICAgIC8vIHRoZXJlIGlzIGEgY3ljbGUsIHNvIHdlIGhhdmUgdG8gYXNzaWduIHByb3BlcnRpZXMgdG8gb3JpZ2luYWwgdGFyZ2V0XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHRhcmdldCwgdGFyZ2V0UHJvcGVydGllcyk7XG4gICAgfVxuICAgIHJlZkVudHJ5LnRhcmdldCA9IHRhcmdldFByb3BlcnRpZXM7IC8vIHRoZSBwbGFjZWhvbGRlciB3YXNuJ3QgdXNlZCwgcmVwbGFjZSB3aXRoIHRoZSBkZXNlcmlhbGl6ZWQgb25lXG4gICAgcmV0dXJuIHRhcmdldFByb3BlcnRpZXM7IC8vIG5vIGN5Y2xlLCBjYW4ganVzdCB1c2UgdGhlIHJldHVybmVkIHJlYWQgb2JqZWN0XG59O1xuZnVuY3Rpb24gY2xlYXJTb3VyY2UoKSB7XG4gICAgc3JjID0gbnVsbDtcbiAgICByZWZlcmVuY2VNYXAgPSBudWxsO1xuICAgIGN1cnJlbnRTdHJ1Y3R1cmVzID0gbnVsbDtcbn1cbmNvbnN0IG11bHQxMCA9IG5ldyBBcnJheSgxNDcpOyAvLyB0aGlzIGlzIGEgdGFibGUgbWF0Y2hpbmcgYmluYXJ5IGV4cG9uZW50cyB0byB0aGUgbXVsdGlwbGllciB0byBkZXRlcm1pbmUgc2lnbmlmaWNhbnQgZGlnaXQgcm91bmRpbmdcbmZvciAobGV0IGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgICBtdWx0MTBbaV0gPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IE51bWJlcihgMWUke01hdGguZmxvb3IoNDUuMTUgLSBpICogMC4zMDEwMyl9YCkpKCk7XG59XG5jb25zdCBkZWZhdWx0RGVjb2RlciA9IG5ldyBEZWNvZGVyKCk7XG5leHBvcnQgY29uc3QgZGVjb2RlID0gZGVmYXVsdERlY29kZXIuZGVjb2RlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2Jvci1kZWNvZGUuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/thirdweb/dist/esm/utils/bytecode/cbor-decode.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/thirdweb/dist/esm/utils/bytecode/extractIPFS.js":
/*!**********************************************************************!*\
  !*** ./node_modules/thirdweb/dist/esm/utils/bytecode/extractIPFS.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   extractIPFSUri: () => (/* binding */ extractIPFSUri)\n/* harmony export */ });\n/* harmony import */ var _base58_encode_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../base58/encode.js */ \"(app-pages-browser)/./node_modules/thirdweb/dist/esm/utils/base58/encode.js\");\n/* harmony import */ var _encoding_to_bytes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../encoding/to-bytes.js */ \"(app-pages-browser)/./node_modules/thirdweb/dist/esm/utils/encoding/to-bytes.js\");\n/* harmony import */ var _cbor_decode_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cbor-decode.js */ \"(app-pages-browser)/./node_modules/thirdweb/dist/esm/utils/bytecode/cbor-decode.js\");\n/* harmony import */ var _prefix_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./prefix.js */ \"(app-pages-browser)/./node_modules/thirdweb/dist/esm/utils/bytecode/prefix.js\");\n\n\n\n\n/**\n * Extracts the IPFS URI from the given bytecode.\n * @param bytecode - The bytecode to extract the IPFS URI from.\n * @returns The IPFS URI if found, otherwise undefined.\n * @example\n * ```ts\n * import { extractIPFSUri } from \"thirdweb/utils/bytecode/extractIPFS\";\n * const bytecode = \"0x363d3d373d3d3d363d30545af43d82803e903d91601857fd5bf3\";\n * const ipfsHash = extractIPFSUri(bytecode);\n * console.log(ipfsHash);\n * ```\n * @utils\n */\nfunction extractIPFSUri(bytecode) {\n    const numericBytecode = (0,_encoding_to_bytes_js__WEBPACK_IMPORTED_MODULE_0__.hexToBytes)((0,_prefix_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytecodePrefix)(bytecode));\n    const cborLength = \n    // @ts-expect-error - TS doesn't like this, but it's fine\n    numericBytecode[numericBytecode.length - 2] * 0x100 +\n        // @ts-expect-error - TS doesn't like this, but it's fine\n        numericBytecode[numericBytecode.length - 1];\n    const cborStart = numericBytecode.length - 2 - cborLength;\n    // if the cborStart is invalid, return undefined\n    if (cborStart < 0 || cborStart > numericBytecode.length) {\n        return undefined;\n    }\n    const bytecodeBuffer = numericBytecode.slice(cborStart, -2);\n    const cborData = (0,_cbor_decode_js__WEBPACK_IMPORTED_MODULE_2__.decode)(bytecodeBuffer);\n    if (\"ipfs\" in cborData) {\n        return `ipfs://${(0,_base58_encode_js__WEBPACK_IMPORTED_MODULE_3__.base58Encode)(cborData.ipfs)}`;\n    }\n    return undefined;\n}\n//# sourceMappingURL=extractIPFS.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aGlyZHdlYi9kaXN0L2VzbS91dGlscy9ieXRlY29kZS9leHRyYWN0SVBGUy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFtRDtBQUNFO0FBQ1g7QUFDUztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGlCQUFpQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLDRCQUE0QixpRUFBVSxDQUFDLGdFQUFvQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHVEQUFNO0FBQzNCO0FBQ0EseUJBQXlCLCtEQUFZLGdCQUFnQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2Rhbmlsby9EZXZlbG9wZXIvRU5WL0Jsb2NrY2hhaW4vd2ViM3Byb2plY3RzL3dlYjNjZi93ZWIzY2ZhcHAvbm9kZV9tb2R1bGVzL3RoaXJkd2ViL2Rpc3QvZXNtL3V0aWxzL2J5dGVjb2RlL2V4dHJhY3RJUEZTLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGJhc2U1OEVuY29kZSB9IGZyb20gXCIuLi9iYXNlNTgvZW5jb2RlLmpzXCI7XG5pbXBvcnQgeyBoZXhUb0J5dGVzIH0gZnJvbSBcIi4uL2VuY29kaW5nL3RvLWJ5dGVzLmpzXCI7XG5pbXBvcnQgeyBkZWNvZGUgfSBmcm9tIFwiLi9jYm9yLWRlY29kZS5qc1wiO1xuaW1wb3J0IHsgZW5zdXJlQnl0ZWNvZGVQcmVmaXggfSBmcm9tIFwiLi9wcmVmaXguanNcIjtcbi8qKlxuICogRXh0cmFjdHMgdGhlIElQRlMgVVJJIGZyb20gdGhlIGdpdmVuIGJ5dGVjb2RlLlxuICogQHBhcmFtIGJ5dGVjb2RlIC0gVGhlIGJ5dGVjb2RlIHRvIGV4dHJhY3QgdGhlIElQRlMgVVJJIGZyb20uXG4gKiBAcmV0dXJucyBUaGUgSVBGUyBVUkkgaWYgZm91bmQsIG90aGVyd2lzZSB1bmRlZmluZWQuXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IGV4dHJhY3RJUEZTVXJpIH0gZnJvbSBcInRoaXJkd2ViL3V0aWxzL2J5dGVjb2RlL2V4dHJhY3RJUEZTXCI7XG4gKiBjb25zdCBieXRlY29kZSA9IFwiMHgzNjNkM2QzNzNkM2QzZDM2M2QzMDU0NWFmNDNkODI4MDNlOTAzZDkxNjAxODU3ZmQ1YmYzXCI7XG4gKiBjb25zdCBpcGZzSGFzaCA9IGV4dHJhY3RJUEZTVXJpKGJ5dGVjb2RlKTtcbiAqIGNvbnNvbGUubG9nKGlwZnNIYXNoKTtcbiAqIGBgYFxuICogQHV0aWxzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0SVBGU1VyaShieXRlY29kZSkge1xuICAgIGNvbnN0IG51bWVyaWNCeXRlY29kZSA9IGhleFRvQnl0ZXMoZW5zdXJlQnl0ZWNvZGVQcmVmaXgoYnl0ZWNvZGUpKTtcbiAgICBjb25zdCBjYm9yTGVuZ3RoID0gXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciAtIFRTIGRvZXNuJ3QgbGlrZSB0aGlzLCBidXQgaXQncyBmaW5lXG4gICAgbnVtZXJpY0J5dGVjb2RlW251bWVyaWNCeXRlY29kZS5sZW5ndGggLSAyXSAqIDB4MTAwICtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciAtIFRTIGRvZXNuJ3QgbGlrZSB0aGlzLCBidXQgaXQncyBmaW5lXG4gICAgICAgIG51bWVyaWNCeXRlY29kZVtudW1lcmljQnl0ZWNvZGUubGVuZ3RoIC0gMV07XG4gICAgY29uc3QgY2JvclN0YXJ0ID0gbnVtZXJpY0J5dGVjb2RlLmxlbmd0aCAtIDIgLSBjYm9yTGVuZ3RoO1xuICAgIC8vIGlmIHRoZSBjYm9yU3RhcnQgaXMgaW52YWxpZCwgcmV0dXJuIHVuZGVmaW5lZFxuICAgIGlmIChjYm9yU3RhcnQgPCAwIHx8IGNib3JTdGFydCA+IG51bWVyaWNCeXRlY29kZS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgYnl0ZWNvZGVCdWZmZXIgPSBudW1lcmljQnl0ZWNvZGUuc2xpY2UoY2JvclN0YXJ0LCAtMik7XG4gICAgY29uc3QgY2JvckRhdGEgPSBkZWNvZGUoYnl0ZWNvZGVCdWZmZXIpO1xuICAgIGlmIChcImlwZnNcIiBpbiBjYm9yRGF0YSkge1xuICAgICAgICByZXR1cm4gYGlwZnM6Ly8ke2Jhc2U1OEVuY29kZShjYm9yRGF0YS5pcGZzKX1gO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXh0cmFjdElQRlMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/thirdweb/dist/esm/utils/bytecode/extractIPFS.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/thirdweb/dist/esm/utils/bytecode/prefix.js":
/*!*****************************************************************!*\
  !*** ./node_modules/thirdweb/dist/esm/utils/bytecode/prefix.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ensureBytecodePrefix: () => (/* binding */ ensureBytecodePrefix)\n/* harmony export */ });\n/* harmony import */ var _encoding_hex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../encoding/hex.js */ \"(app-pages-browser)/./node_modules/thirdweb/dist/esm/utils/encoding/helpers/is-hex.js\");\n\n/**\n * Ensures that the given bytecode has the correct prefix.\n * If the bytecode already starts with \"0x\", it is returned as is.\n * Otherwise, the prefix \"0x\" is added to the bytecode.\n * @param bytecode - The bytecode to ensure the prefix for.\n * @returns The bytecode with the correct prefix.\n * @example\n * ```ts\n * import { ensureBytecodePrefix } from \"thirdweb/utils/bytecode/prefix\";\n * const bytecode = \"363d3d373d3d3d363d30545af43d82803e903d91601857fd5bf3\";\n * const prefixedBytecode = ensureBytecodePrefix(bytecode);\n * console.log(prefixedBytecode);\n * ```\n * @utils\n */\nfunction ensureBytecodePrefix(bytecode) {\n    if ((0,_encoding_hex_js__WEBPACK_IMPORTED_MODULE_0__.isHex)(bytecode, { strict: false })) {\n        return bytecode;\n    }\n    return `0x${bytecode}`;\n}\n//# sourceMappingURL=prefix.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aGlyZHdlYi9kaXN0L2VzbS91dGlscy9ieXRlY29kZS9wcmVmaXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksdUJBQXVCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsUUFBUSx1REFBSyxhQUFhLGVBQWU7QUFDekM7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9kYW5pbG8vRGV2ZWxvcGVyL0VOVi9CbG9ja2NoYWluL3dlYjNwcm9qZWN0cy93ZWIzY2Yvd2ViM2NmYXBwL25vZGVfbW9kdWxlcy90aGlyZHdlYi9kaXN0L2VzbS91dGlscy9ieXRlY29kZS9wcmVmaXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNIZXggfSBmcm9tIFwiLi4vZW5jb2RpbmcvaGV4LmpzXCI7XG4vKipcbiAqIEVuc3VyZXMgdGhhdCB0aGUgZ2l2ZW4gYnl0ZWNvZGUgaGFzIHRoZSBjb3JyZWN0IHByZWZpeC5cbiAqIElmIHRoZSBieXRlY29kZSBhbHJlYWR5IHN0YXJ0cyB3aXRoIFwiMHhcIiwgaXQgaXMgcmV0dXJuZWQgYXMgaXMuXG4gKiBPdGhlcndpc2UsIHRoZSBwcmVmaXggXCIweFwiIGlzIGFkZGVkIHRvIHRoZSBieXRlY29kZS5cbiAqIEBwYXJhbSBieXRlY29kZSAtIFRoZSBieXRlY29kZSB0byBlbnN1cmUgdGhlIHByZWZpeCBmb3IuXG4gKiBAcmV0dXJucyBUaGUgYnl0ZWNvZGUgd2l0aCB0aGUgY29ycmVjdCBwcmVmaXguXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IGVuc3VyZUJ5dGVjb2RlUHJlZml4IH0gZnJvbSBcInRoaXJkd2ViL3V0aWxzL2J5dGVjb2RlL3ByZWZpeFwiO1xuICogY29uc3QgYnl0ZWNvZGUgPSBcIjM2M2QzZDM3M2QzZDNkMzYzZDMwNTQ1YWY0M2Q4MjgwM2U5MDNkOTE2MDE4NTdmZDViZjNcIjtcbiAqIGNvbnN0IHByZWZpeGVkQnl0ZWNvZGUgPSBlbnN1cmVCeXRlY29kZVByZWZpeChieXRlY29kZSk7XG4gKiBjb25zb2xlLmxvZyhwcmVmaXhlZEJ5dGVjb2RlKTtcbiAqIGBgYFxuICogQHV0aWxzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbnN1cmVCeXRlY29kZVByZWZpeChieXRlY29kZSkge1xuICAgIGlmIChpc0hleChieXRlY29kZSwgeyBzdHJpY3Q6IGZhbHNlIH0pKSB7XG4gICAgICAgIHJldHVybiBieXRlY29kZTtcbiAgICB9XG4gICAgcmV0dXJuIGAweCR7Ynl0ZWNvZGV9YDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByZWZpeC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/thirdweb/dist/esm/utils/bytecode/prefix.js\n"));

/***/ })

}]);